# 系统设计

## Spring

### 什么是 Spring 框架?

### 列举一些重要的 Spring 模块？

### 谈谈自己对于 Spring IoC 和 AOP 的理解

### Spring Bean 的生命周期说一下

### Spring 中的 bean 的作用域有哪些?

### 拦截器和过滤器了解么？

### Spring 动态代理默认用哪一种

### hibernate 和 mybatis 区别

### Spring Boot 和 Spring 的区别

### 说出使用 Spring Boot 的主要优点

### 什么是 Spring Boot Starter?

### 介绍一下 @SpringBootApplication 注解

### Spring Boot 的自动配置是如何实现的?

### Spring Boot 支持哪些嵌入式 web 容器？



## 设计模式

### 何为设计模式？有哪些常见的设计模式？

设计模式（Design pattern）代表了最佳的实践，通常被有经验的⾯向对象 的软件开发⼈员所采⽤。设计模式是软件开发⼈员在软件开发过程中⾯临 的⼀般问题的解决⽅案。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的。

设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设 计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。 毫⽆疑问，设计模式于⼰于他⼈于系统都是多赢的，设计模式使代码编制真正⼯程化，设计模式是软件⼯程的基⽯，如同⼤厦的⼀块块砖⽯⼀样。项⽬中合理地运⽤设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也是设计模式能被⼴泛应⽤的原因。

**设计模式的分类**

+ **创建型**： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/ 建造者/原型模式。
+ **结构型**： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包 括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。
+ **⾏为型**： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解 释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。

![image-20250213230036008](frequentQ.assets/image-20250213230036008.png)

### 单例模式了解么？说一下单例模式的使用场景。手写一个单例模式的实现。

### 观察者模式了解么？说一下观察者模式的使用场景。

### 工厂模式了解么？说一下工厂模式的使用场景。

### 责任链模式了解么？哪些开源项目（Netty、MyBatis ...）中用到了责任链模式？怎么用的？

### SOLID 原则了解么？简单谈谈自己对于单⼀职责原则和开闭原则的理解。

### 阅读 Spring 源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？



## 权限认证

### 认证 (Authentication) 和授权 (Authorization)的区别是什么？

- **认证 (Authentication)：** 你是谁。
- **授权 (Authorization)：** 你有权限干什么。

**Authentication（认证）** 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。

**Authorization（授权）** 发生在 **Authentication（认证）** 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。

### 什么是 Cookie ? Cookie 的作用是什么？

`Cookie` 和 `Session` 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

维基百科是这样定义 `Cookie` 的：

> `Cookies` 是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。

简单来说：**`Cookie` 存放在客户端，一般用来保存用户信息**。

下面是 `Cookie` 的一些应用案例：

1. 我们在 `Cookie` 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，`Cookie` 还能保存用户首选项，主题和其他设置信息。
2. 使用 `Cookie` 保存 `SessionId` 或者 `Token` ，向后端发送请求的时候带上 `Cookie`，这样后端就能取到 `Session` 或者 `Token` 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。
3. `Cookie` 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 `Cookie`

### 如何在服务端使用 Cookie?

以 Spring Boot 项目为例。

**1)设置 `Cookie` 返回给客户端**

```java
@GetMapping("/change-username")
public String setCookie(HttpServletResponse response) {
    // 创建一个 cookie
    Cookie cookie = new Cookie("username", "Jovan");
    //设置 cookie过期时间
    cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days
    //添加到 response 中
    response.addCookie(cookie);

    return "Username is changed!";
}
```

**2) 使用 Spring 框架提供的 `@CookieValue` 注解获取特定的 cookie 的值**

```java
@GetMapping("/")
public String readCookie(@CookieValue(value = "username", defaultValue = "Atta") String username) {
    return "Hey! My username is " + username;
}
```

**3) 读取所有的 `Cookie` 值**

```java
@GetMapping("/all-cookies")
public String readAllCookies(HttpServletRequest request) {

    Cookie[] cookies = request.getCookies();
    if (cookies != null) {
        return Arrays.stream(cookies)
                .map(c -> c.getName() + "=" + c.getValue()).collect(Collectors.joining(", "));
    }

    return "No cookies";
}
```

### Cookie 和 Session 有什么区别？

**`Session` 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了。

`Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。

### 如何使用 Session 进行身份验证？

很多时候我们都是通过 `SessionID` 来实现特定的用户，`SessionID` 一般会选择存放在 Redis 中。举个例子：

1. 用户成功登陆系统，然后返回给客户端具有 `SessionID` 的 `Cookie` 。
2. 当用户向后端发起请求的时候会把 `SessionID` 带上，这样后端就知道你的身份状态了。

![img](frequentQ.assets/session-cookie-authentication-process.png)

用户向服务器发送用户名、密码、验证码用于登陆系统。

服务器验证通过后，服务器为用户创建一个 `Session`，并将 `Session` 信息存储起来。

服务器向用户返回一个 `SessionID`，写入用户的 `Cookie`。

当用户保持登录状态时，`Cookie` 将与每个后续请求一起被发送出去。

服务器可以将存储在 `Cookie` 上的 `SessionID` 与存储在内存中或者数据库中的 `Session` 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。

使用 `Session` 的时候需要注意下面几个点：

- 依赖 `Session` 的关键业务一定要确保客户端开启了 `Cookie`。
- 注意 `Session` 的过期时间。

### 如果没有 Cookie 的话 Session 还能用吗？

一般是通过 `Cookie` 来保存 `SessionID` ，假如你使用了 `Cookie` 保存 `SessionID` 的方案的话， 如果客户端禁用了 `Cookie`，那么 `Session` 就无法正常工作。

但是，并不是没有 `Cookie` 之后就不能用 `Session` 了，比如你可以将 `SessionID` 放在请求的 `url` 里面`https://javaguide.cn/?Session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了安全你也可以对 `SessionID` 进行一次加密之后再传入后端。

### 为什么 Cookie 无法防止 CSRF 攻击，而 token 可以？

**CSRF(Cross Site Request Forgery)** 一般被翻译为 **跨站请求伪造** 。那么什么是 **跨站请求伪造** 呢？说简单点，就是用你的身份去发送一些对你不友好的请求。举个简单的例子：

小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。

```html
<a src=http://www.mybank.com/Transfer?bankId=11&money=10000>科学理财，年盈利率过万</>
```

进行 `Session` 认证的时候，我们一般使用 `Cookie` 来存储 `SessionId`,当我们登陆后后端生成一个 `SessionId` 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 `SessionId`，客户端登录以后每次请求都会带上这个 `SessionId`，服务端通过这个 `SessionId` 来标示你这个人。如果别人通过 `Cookie` 拿到了 `SessionId` 后就可以代替你的身份访问系统了。

`Session` 认证中 `Cookie` 中的 `SessionId` 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。

但是，我们使用 `Token` 的话就不会存在这个问题，在我们登录成功获得 `Token` 之后，一般会选择存放在 `localStorage` （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 `Token`,这样就不会出现 CSRF 漏洞的问题。因为，即使你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 `Token` 的，所以这个请求将是非法的。

需要注意的是：不论是 `Cookie` 还是 `Token` 都无法避免 **跨站脚本攻击（Cross Site Scripting）XSS** 。

> 跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为 XSS。

XSS 中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如 `Cookie` 。

### 什么是 Token？什么是 JWT？如何基于 Token 进行身份验证？

[JWT 基础概念详解](https://javaguide.cn/system-design/security/jwt-intro.html)

#### Token

- 定义：Token 通常是指访问令牌，是一种用于验证和授权用户访问资源的字符串或代码。它相当于用户的 “通行证”，代表了用户的身份和权限信息。
- 作用：在用户登录系统后，服务器会为用户生成一个唯一的 token 并返回给客户端。客户端在后续请求中携带这个 token，服务器通过验证 token 的有效性来确定用户是否有权访问请求的资源，从而实现身份验证和授权。

#### JWT（JSON Web Token）

定义：JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。

JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。

可以看出，**JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则** 。

并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。

**组成部分**

- 头部：通常包含令牌的类型（如 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA）等信息。
- 载荷：包含了实际的用户信息和元数据，如用户 ID、用户名、角色、过期时间等。这些信息以键值对的形式存储。
- 签名：用于验证 JWT 的完整性和真实性，防止 JWT 被篡改。它是通过使用头部中指定的算法，对头部和载荷进行签名生成的。

#### 基于 Token 的身份验证流程

1. **用户登录**：用户在客户端输入用户名和密码等凭证进行登录。
2. **服务器验证**：客户端将用户凭证发送到服务器，服务器验证用户身份信息。如果验证成功，服务器会为该用户生成一个 token。
3. **返回 Token**：服务器将生成的 token 返回给客户端，客户端通常会将 token 存储在本地，如浏览器的 localStorage 中，放在 Cookie 中会有 CSRF 风险。
4. **后续请求**：在客户端发起后续请求时，会在请求头中添加 token，一般是在 `Authorization` 字段中，格式为 `Bearer [token]`。
5. **服务器验证**：服务器接收到请求后，从请求头中提取 token，并对其进行验证，检查 token 的有效性、是否过期等。
6. **授权访问**：如果 token 验证通过，服务器根据 token 中包含的用户信息和权限，允许用户访问相应的资源；如果验证失败，则返回错误信息，拒绝用户访问。

[JWT 身份认证优缺点分析](https://javaguide.cn/system-design/security/advantages-and-disadvantages-of-jwt.html)

### 什么是 OAuth 2.0？

OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。详情请见：[rfc6749](https://tools.ietf.org/html/rfc6749)。

实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。

OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。

另外，现在 OAuth 2.0 也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。

### 什么是 SSO(单点登录)？SSO 有什么好处？

https://javaguide.cn/system-design/security/sso-intro.html

SSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。举个例子我们在登陆了京东金融之后，我们同时也成功登陆京东的京东超市、京东国际、京东生鲜等子系统。

**SSO的好处：**

+ **用户角度** :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。
+ **系统管理员角度** : 管理员只需维护好一个统一的账号中心就可以了，方便。
+ **新系统开发角度:** 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。

### RBAC 权限模型了解吗？和 ABAC 权限模型有何区别？如何选择？

#### RBAC 权限模型

- **定义**：RBAC 模型基于用户所担任的角色来分配访问权限。将用户与角色关联，角色与权限关联，用户通过成为相应角色的成员而获得该角色所拥有的权限。
- **组成要素**：主要包括用户、角色、权限和会话。用户是系统的使用者，角色代表了用户在系统中的职位或职责，权限定义了对系统资源的操作许可，会话是用户与系统交互的过程，用户在会话期间激活一个或多个角色来访问资源。

#### ABAC 权限模型

- **定义**：ABAC 模型依据用户、资源和环境等多方面的属性来进行访问控制决策。通过定义一系列基于属性的规则，系统根据这些规则和相关主体、客体的属性值来判断是否允许访问。
- **组成要素**：包括主体属性（如用户的年龄、部门等）、客体属性（如文件的创建时间、所属类别等）、环境属性（如当前时间、网络位置等）和策略（由属性和操作符组成的访问控制规则）。

#### 两者区别

- **授权依据**：RBAC 基于角色进行授权，ABAC 基于属性进行授权。
- **灵活性**：RBAC 中权限与角色绑定，当组织结构变化时，可能需要重新配置角色和权限；ABAC 基于属性定义规则，在应对复杂多变的访问控制需求时更灵活，无需大量修改配置。
- **管理复杂度**：RBAC 的角色和权限管理相对集中和直观；ABAC 需管理大量的属性和规则，管理复杂度较高。
- **适用场景**：RBAC 适用于组织结构相对稳定、权限管理层次清晰的系统；ABAC 适用于对访问控制有高度灵活性和细粒度要求的场景，如云计算、大数据平台等。

#### 选择方法

- **考虑系统规模和复杂度**：小型简单系统用 RBAC 便于管理和维护；大型复杂且访问控制需求多变的系统宜用 ABAC。
- **依据业务需求特点**：业务流程固定、权限与职位关联紧密的选 RBAC；业务场景复杂、需根据多种属性动态授权的选 ABAC。
- **权衡管理成本和效率**：希望管理简单高效，对灵活性要求不高时选 RBAC；愿意投入更多管理成本以换取高度灵活的访问控制则选 ABAC。


