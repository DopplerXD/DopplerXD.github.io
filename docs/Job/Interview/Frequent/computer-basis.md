# 计算机基础

## 计算机网络

### OSI 与 TCP/IP 各层的结构与功能。

#### OSI 七层模型

![OSI 七层模型](frequentQ.assets/osi-7-model.png)

![osi七层模型2](frequentQ.assets/osi七层模型2.png)

#### TCP/IP 四层模型

![TCP/IP 各层协议概览](frequentQ.assets/network-protocol-overview.png)

**应用层位于传输层之上，主要提两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。** 我们把应用层交互的数据单元称为报文。应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

**传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。** 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

**网络层负责为分组交换网上的不同主机提供通信服务。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。

**网络接口层可以看作是数据链路层和物理层的合体。**

1. 数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。**数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。**
2. **物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**

### 为什么网络要分层？

说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:

1. Repository（数据库操作）
2. Service（业务操作）
3. Controller（前后端数据交互）

**复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。**

1. **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理。**
2. **提高了整体灵活性**：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。**
3. **大问题化小**：分层可以将复杂的网络问题分解为许多比较小的、界限比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。**

我想到了计算机世界非常非常有名的一句话，这里分享一下：

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。

### OSI 与 TCP/IP 各层都有哪些协议? 

#### 应用层

**HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

**SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）**：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。

**POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。

**FTP（File Transfer Protocol，文件传输协议）** : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。

**Telnet（远程登陆协议）**：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。

**SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务

**RTP（Real-time Transport Protocol，实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。

**DNS（Domain Name System，域名管理系统）**: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

#### 传输层

**TCP（Transmission Control Protocol，传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。

**UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。

#### 网络层

**IP（Internet Protocol，网际协议）**：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

**ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。

**ICMP（Internet Control Message Protocol，互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。

**NAT（Network Address Translation，网络地址转换协议）**：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。

**OSPF（Open Shortest Path First，开放式最短路径优先）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。

**RIP(Routing Information Protocol，路由信息协议）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。

**BGP（Border Gateway Protocol，边界网关协议）**：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。

### TCP 的三次握手与四次挥手的内容？ TCP 为什么连接是三次握手而断开是四次握手？

https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html

### TCP 与 UDP 的区别及使用场景？

|                        | TCP            | UDP            |
| ---------------------- | -------------- | -------------- |
| 是否面向连接           | 是             | 否             |
| 是否可靠               | 是             | 否             |
| 是否有状态             | 是             | 否             |
| 传输效率               | 较慢           | 较快           |
| 传输形式               | 面向字节流     | 面向数据报文段 |
| 首部开销               | 20 ～ 60 bytes | 8 bytes        |
| 是否提供广播或多播服务 | 否             | 是             |

**UDP 一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。

**TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

### 为什么 DNS 协议使用 UDP？只使用了 UDP 吗？

DNS 协议主要使用 UDP，但在某些情况下也会使用 TCP，具体原因如下：

#### 主要使用 UDP 的原因

- **效率高**：UDP 是无连接的协议，在进行 DNS 查询时，无需像 TCP 那样进行三次握手等连接建立过程，能快速地发送和接收查询请求与响应，提高了查询效率。
- **轻量化**：DNS 查询和响应的数据量通常相对较小，UDP 的头部开销小，一般为 8 字节，适合传输这种短小的数据，能有效利用网络带宽。
- **支持广播和多播**：UDP 支持广播和多播功能，在某些局域网环境下，DNS 服务器可以利用广播或多播的方式向多个客户端同时发送 DNS 信息，方便进行域名解析。

#### 也会使用 TCP 的情况

- **区域传输**：在进行 DNS 区域传输时，由于传输的数据量较大，需要保证数据的完整性和准确性，TCP 的可靠传输机制能确保数据无差错、无丢失地传输。
- **响应超过 512 字节**：当 DNS 响应数据超过 512 字节时，UDP 可能会截断数据，导致信息不完整。此时就需要使用 TCP 来进行传输，因为 TCP 能够处理大数据包，保证数据的完整传输。

### TCP 是如何保证传输的可靠性？（知识点多，能挖掘不少问题，如重传机制、流量控制、拥塞控制。大厂面试常问）

https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html

### 使用 TCP 的协议有哪些？使用 UDP 的协议有哪些？

**运行于 TCP 协议之上的协议**：

1. **HTTP 协议（HTTP/3.0 之前）**：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
2. **HTTPS 协议**：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议
3. **FTP 协议**：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。
4. **SMTP 协议**：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。
5. **POP3/IMAP 协议**：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。
6. **Telnet 协议**：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。
7. **SSH 协议** : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。

**运行于 UDP 协议之上的协议**：

1. **HTTP 协议（HTTP/3.0 ）**： HTTP/3.0 弃用 TCP，改用基于 UDP 的 QUIC 协议 。
2. **DHCP 协议**：动态主机配置协议，动态配置 IP 地址
3. **DNS**：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，[www.baidu.com](http://www.baidu.com)) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上，DNS 同时支持 UDP 和 TCP 协议。

### HTTP 基于 TCP 还是 UDP？

HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 **基于 UDP 的 QUIC 协议** 。

此变化解决了 HTTP/2 中存在的队头阻塞问题。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。

除了解决队头阻塞问题，HTTP/3.0 还可以减少握手过程的延迟。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：

1. TCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。
2. TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。

所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。

### HTTP 状态码有哪些？

![常见 HTTP 状态码](frequentQ.assets/http-status-code.png)

### 一次完整的 HTTP 请求所经的步骤 

#### 1. DNS 解析

- 客户端要访问某个网站时，首先需要知道该网站服务器的 IP 地址。但用户通常输入的是域名（如 `www.example.com`），所以客户端会先向本地 DNS 服务器发送请求，查询该域名对应的 IP 地址。
- 若本地 DNS 服务器没有该记录，会向上级 DNS 服务器递归查询，直到找到对应的 IP 地址或者返回查询失败信息。

#### 2. TCP 连接建立（TCP 三次握手）

- 客户端获取到服务器的 IP 地址和端口号（HTTP 默认端口是 80，HTTPS 默认端口是 443）后，会通过 TCP 协议与服务器建立连接。
- **第一次握手**：客户端向服务器发送一个 SYN 包，包含客户端的初始序列号（ISN），表明客户端请求建立连接。
- **第二次握手**：服务器收到 SYN 包后，向客户端发送一个 SYN + ACK 包，包含服务器的初始序列号和对客户端 SYN 包的确认号，表明服务器同意建立连接。
- **第三次握手**：客户端收到 SYN + ACK 包后，向服务器发送一个 ACK 包，包含对服务器 SYN 包的确认号，此时连接建立成功。

#### 3. HTTP 请求发送

- 连接建立后，客户端会根据请求类型（如 GET、POST 等）构造 HTTP 请求消息。请求消息通常包含请求行（如 `GET /index.html HTTP/1.1`）、请求头（包含各种请求信息，如 `User - Agent`、`Accept` 等）和请求体（POST 请求可能包含提交的数据）。
- 客户端将构造好的 HTTP 请求消息通过 TCP 连接发送给服务器。

#### 4. 服务器处理请求

- 服务器接收到客户端的 HTTP 请求后，首先解析请求消息，获取请求的方法、请求的资源路径、请求头等信息。
- 服务器根据请求信息进行相应的处理，如从数据库中查询数据、调用业务逻辑处理程序等。

#### 5. HTTP 响应返回

- 服务器处理完请求后，会构造 HTTP 响应消息。响应消息包含状态行（如 `HTTP/1.1 200 OK`）、响应头（包含各种响应信息，如 `Content - Type`、`Content - Length` 等）和响应体（包含请求的资源内容，如 HTML 页面、JSON 数据等）。
- 服务器将构造好的 HTTP 响应消息通过 TCP 连接发送给客户端。

#### 6. TCP 连接关闭（TCP 四次挥手）

- 客户端收到服务器的响应后，可能会根据情况选择关闭 TCP 连接。
- **第一次挥手**：客户端向服务器发送一个 FIN 包，表明客户端请求关闭连接。
- **第二次挥手**：服务器收到 FIN 包后，向客户端发送一个 ACK 包，表明服务器同意关闭客户端到服务器方向的连接。
- **第三次挥手**：服务器向客户端发送一个 FIN 包，表明服务器请求关闭服务器到客户端方向的连接。
- **第四次挥手**：客户端收到 FIN 包后，向服务器发送一个 ACK 包，表明客户端同意关闭服务器到客户端方向的连接，此时连接关闭。

#### 7. 客户端解析渲染页面

- 若响应内容是 HTML 页面，客户端的浏览器会解析 HTML、CSS 和 JavaScript 代码。
- 浏览器根据解析结果构建 DOM 树和渲染树，将页面元素绘制到屏幕上，最终呈现给用户。

### 什么是 HTTP 协议？

#### HTTP 概述

HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在互联网上传输超文本的协议，它是万维网数据通信的基础，为浏览器和 Web 服务器之间的通信提供了一种标准方式。其主要特点如下：

- **无状态**：每个请求都是独立的，服务器不会保留之前请求的信息。这有助于提高服务器的处理效率，但在需要记录用户状态的场景下，需要借助额外技术（如 Cookie、Session）。
- **简单快速**：请求方式（如 GET、POST 等）简单，服务器能够快速响应处理。
- **灵活**：可以传输多种类型的数据，通过设置请求头和响应头中的 `Content-Type` 字段指定数据类型。

### HTTP 报文的内容简单说⼀下！HTTP 请求报文和响应报文中有哪些数据？

#### HTTP 请求报文

HTTP 请求报文是客户端向服务器发送请求时使用的报文，主要包含以下几个部分：

- **请求行**：位于请求报文的第一行，包含三个部分，分别是请求方法（如 GET、POST、PUT、DELETE 等）、请求的 URI（统一资源标识符，标识请求的资源路径）和 HTTP 协议版本（如 HTTP/1.1）。例如：`GET /index.html HTTP/1.1`。
- **请求头**：由多个键值对组成，每个键值对占一行，用于传递关于请求的额外信息。常见的请求头字段有：
    - `User - Agent`：标识客户端的类型和版本，如浏览器的类型和版本信息。
    - `Accept`：表示客户端能够接受的响应数据类型，如 `text/html` 表示接受 HTML 格式的数据。
    - `Cookie`：用于传递客户端存储的 Cookie 信息，服务器可以根据这些信息识别客户端。
- **空行**：请求头和请求体之间用一个空行分隔，用于标识请求头的结束。
- **请求体**：可选部分，主要用于 POST、PUT 等请求方法中，携带客户端要发送给服务器的数据。例如，在表单提交时，表单数据会作为请求体发送给服务器。

#### HTTP 响应报文

HTTP 响应报文是服务器在接收到客户端请求后返回给客户端的报文，主要包含以下几个部分：

- **状态行**：位于响应报文的第一行，包含三个部分，分别是 HTTP 协议版本（如 HTTP/1.1）、状态码（用于表示请求的处理结果，如 200 表示成功，404 表示未找到资源）和状态消息（对状态码的简短描述，如 `OK`、`Not Found` 等）。例如：`HTTP/1.1 200 OK`。
- **响应头**：同样由多个键值对组成，用于传递关于响应的额外信息。常见的响应头字段有：
    - `Content - Type`：表示响应数据的类型，如 `text/html` 表示响应数据是 HTML 格式。
    - `Content - Length`：表示响应体的长度，单位为字节。
    - `Set - Cookie`：服务器用于向客户端发送 Cookie 信息。
- **空行**：响应头和响应体之间用一个空行分隔，用于标识响应头的结束。
- **响应体**：包含服务器返回给客户端的实际数据，如 HTML 页面、JSON 数据、图片等。

### HTTP 和 HTTPS 的区别了解么？

**端口号**：HTTP 默认是 80，HTTPS 默认是 443。

**URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

**SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS 的安全性体现在什么方面？（本质还是在问 HTTPS 原理）

HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险： 

+ 窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。 
+ 篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。 
+ 冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。 

HTTPS 在 HTTP 与 TCP 层之间加⼊了  SSL/TLS 协议，可以很好的解决了上述的⻛险： 

+ 信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。 
+ 校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。 
+ 身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。 

可⻅，只要⾃身不做「恶」，SSL/TLS 协议是能保证通信是安全的。 

HTTPS 是如何解决上⾯的三个⻛险的？ 

+ 混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。 
+ 摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。 
+ 将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。 

#### 1 混合加密 

通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。

![混合加密](frequentQ.assets/20-混合加密.png)

HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式： 

+ 在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。 
+ 在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。 

采⽤「混合加密」的⽅式的原因： 

+ 对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。 
+ ⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。 

#### 2 摘要算法

摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。 客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发 送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出 的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。

#### 3 数字证书

客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。

这就存在些问题，如何保证公钥不被篡改和信任度？

所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证 机构颁发）中，只要证书是可信的，公钥就是可信的。 通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。 

### HTTPS 加密过程是怎么样的？

HTTPS 的加密过程主要基于 SSL/TLS 协议，通常包含以下几个步骤：

#### 客户端发起连接

- 客户端向服务器发送一个 `ClientHello` 消息，包含客户端支持的 SSL/TLS 版本、加密算法列表、压缩算法列表等信息，同时还会生成一个随机数 `ClientRandom`。

#### 服务器响应

- 服务器接收到 `ClientHello` 消息后，选择一个 SSL/TLS 版本和加密算法，并发送 `ServerHello` 消息给客户端，包含服务器选择的版本、加密算法、服务器生成的随机数 `ServerRandom` 和服务器自己的数字证书等信息。
- 最后，服务器发送 `ServerHelloDone` 消息，表示服务器的初始响应结束。

#### 客户端验证证书并生成会话密钥

- 客户端接收到服务器的证书后，会验证证书的有效性，包括检查证书的颁发机构、证书是否过期等。
- 如果证书验证通过，客户端会生成一个新的随机数 `PreMasterSecret`，并使用服务器证书中的公钥对其进行加密，然后将加密后的 `PreMasterSecret` 发送给服务器。
- 客户端和服务器分别使用 `ClientRandom`、`ServerRandom` 和 `PreMasterSecret` 生成会话密钥 `SessionKey`，这个会话密钥将用于后续的数据加密和解密。

#### 客户端和服务器交换确认信息

- 客户端发送 `ChangeCipherSpec` 消息，表示后续的通信将使用新生成的会话密钥进行加密。
- 客户端发送 `Finished` 消息，该消息经过会话密钥加密，用于验证密钥交换和身份验证过程是否成功。
- 服务器接收到 `ChangeCipherSpec` 消息后，也发送 `ChangeCipherSpec` 消息，表示后续的通信将使用会话密钥进行加密。
- 服务器发送 `Finished` 消息，同样经过会话密钥加密，用于验证整个握手过程的完整性。

#### 数据传输

- 经过上述步骤，客户端和服务器之间建立了安全的连接。后续的数据传输将使用会话密钥进行加密和解密，确保数据的机密性和完整性。当通信结束时，双方关闭连接。

#### 要点

https 先使用非对称加密，客户端和服务器端都得到3个随机数，计算会话密钥，然后在通过对称加密，使用会话密钥对信息进行加密。

对称加密的速度相对要快于非对称加密，因此最后使用对称加密来加密数据。

前两个随机数是明文的，而第三个随机数 `PreMasterSecret` 是使用服务器公钥加密的。

### HTTP/1.0 和 HTTP/1.1 有什么区别？

**连接方式** : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

**状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。

**缓存机制** : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

**带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

**Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

### HTTP/1.1 和 HTTP/2.0 有什么区别？

**多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。

**二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。

**头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。

**服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

HTTP/2.0 多路复用效果图

![HTTP/2 Multiplexing](frequentQ.assets/http2.0-multiplexing.png)

可以看到，HTTP/2.0 的多路复用使得不同的请求可以共用一个 TCP 连接，避免建立多个连接带来不必要的额外开销，而 HTTP/1.1 中的每个请求都会建立一个单独的连接

### HTTP/2.0 和 HTTP/3.0 有什么区别？

**传输协议**：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。

**连接建立**：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。

**头部压缩**：HTTP/2.0 使用 HPACK 算法进行头部压缩，而 HTTP/3.0 使用更高效的 QPACK 头压缩算法。

**队头阻塞**：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。

**连接迁移**：HTTP/3.0 支持连接迁移，因为 QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。

**错误恢复**：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。

**安全性**：在 HTTP/2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP/3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。

### HTTP 长连接和短连接了解么？

#### HTTP 短连接

- **概念**：短连接是指客户端与服务器进行一次请求 - 响应交互后就断开连接。每次进行新的请求时，都需要重新建立 TCP 连接。在早期的 HTTP/1.0 协议中，默认使用短连接。
- 特点
    - **连接建立和断开频繁**：每次请求都要经历 TCP 三次握手建立连接，请求完成后又通过 TCP 四次挥手断开连接，会带来一定的性能开销。
    - **资源占用时间短**：连接在请求响应完成后即关闭，不会长时间占用服务器资源，但频繁的连接和断开操作也会消耗一定的系统资源。

#### HTTP 长连接

- **概念**：长连接是指客户端与服务器建立连接后，在一段时间内保持连接不断开，可以进行多次请求 - 响应交互。在 HTTP/1.1 协议中，默认开启长连接，通过在请求头和响应头中添加 `Connection: keep - alive` 字段来标识。
- 特点
    - **减少连接开销**：避免了每次请求都进行 TCP 连接的建立和断开操作，提高了请求响应的效率，尤其适用于频繁交互的场景。
    - **资源占用时间长**：连接会在一段时间内保持，可能会占用服务器的资源，因此服务器需要对长连接进行管理，设置合理的超时时间。

### Cookie 和 Session 的关系？

**`Session` 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了。

`Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。相对来说 `Session` 安全性更高。如果使用 `Cookie` ，不要将敏感信息写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。

#### 共同点

- **目的相同**：都是为了解决 HTTP 协议无状态的问题，用于在客户端和服务器之间保持用户的会话状态，以便服务器能够识别不同的用户请求。

#### 区别

- 存储位置

    - **Cookie**：数据存储在客户端浏览器中。当服务器向客户端发送响应时，可以在响应头中设置 `Set - Cookie` 字段，将 Cookie 信息发送给客户端，客户端将其存储在本地。
    - **Session**：数据存储在服务器端。服务器为每个客户端创建一个唯一的会话标识（Session ID），并将该 ID 发送给客户端，客户端将其存储在 Cookie 中（也可以通过 URL 重写等方式传递）。

    

- 安全性

    - **Cookie**：由于存储在客户端，容易被篡改或窃取，安全性相对较低。敏感信息一般不适合存储在 Cookie 中。
    - **Session**：数据存储在服务器端，相对安全。但 Session ID 可能会被窃取，导致会话劫持等安全问题。

    

- 数据大小限制

    - **Cookie**：单个 Cookie 的大小通常有限制（一般为 4KB 左右），且浏览器对每个域名下的 Cookie 数量也有限制。
    - **Session**：服务器端存储数据的大小理论上没有限制，但会受到服务器内存等资源的限制。

#### 关系

- Cookie 是实现 Session 的一种常用方式。服务器通过 Cookie 将 Session ID 发送给客户端，客户端在后续的请求中携带该 Session ID 发送给服务器，服务器根据 Session ID 查找对应的会话信息，从而实现对用户会话状态的跟踪。但 Session 也可以不依赖 Cookie 实现，例如通过 URL 重写的方式将会话 ID 附加在 URL 后面传递。

### URI 和 URL 的区别是什么? 

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### GET 和 POST 的区别？ 

GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：

- 语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
- 幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。
- 格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。
- 缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。
- 安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。

再次提示，重点搞清两者在语义上的区别即可，实际使用过程中，也是通过语义来区分使用 GET 还是 POST。不过，也有一些项目所有的请求都用 POST，这个并不是固定的，项目组达成共识即可。

### 什么是 WebSocket？⼀般用来做什么？

WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。

WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。

WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

下面是 WebSocket 的常见应用场景：

- 视频弹幕
- 实时消息推送
- 实时游戏对战
- 多用户协同编辑
- 社交聊天

### WebSocket 和 HTTP 有什么区别？

WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。

下面是二者的主要区别：

- WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。
- WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。
- WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
- WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。

### WebSocket 的工作过程是什么样的？

WebSocket 的工作过程可以分为以下几个步骤：

1. 客户端向服务器发送一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key` 等字段，表示要求升级协议为 WebSocket；
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，`Connection: Upgrade`和 `Sec-WebSocket-Accept: xxx` 等字段、表示成功升级到 WebSocket 协议。
3. 客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。

另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。

### SSE 与 WebSocket 该如何选择？

SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：

- SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。
- SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。
- SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。
- SSE 默认支持断线重连；WebSocket 则需要自己实现。
- SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。

**SSE 与 WebSocket 该如何选择？**

SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。

但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SSE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。

### PING 命令的作用是什么？

PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。

PING 命令的输出结果通常包括以下几部分信息：

1. **ICMP Echo Request（请求报文）信息**：序列号、TTL（Time to Live）值。
2. **目标主机的域名或 IP 地址**：输出结果的第一行。
3. **往返时间（RTT，Round-Trip Time）**：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。
4. **统计结果（Statistics）**：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。

如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对 ICMP 请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。

### PING 命令的工作原理是什么？

PING 基于网络层的 **ICMP（Internet Control Message Protocol，互联网控制报文协议）**，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：

- **查询报文类型**：向目标主机发送请求并期望得到响应。
- **差错报文类型**：向源主机发送错误信息，用于报告网络中的错误情况。

PING 用到的 ICMP Echo Request（类型为 8）和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。

- PING 命令会向目标主机发送 ICMP Echo Request。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

### DNS 是什么？解决了什么问题？

DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是**域名和 IP 地址的映射问题**。

![DNS:域名系统](frequentQ.assets/dns-overview.png)

在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么 DNS 就闪亮登场了。

目前 DNS 的设计采用的是分布式、层次数据库结构，**DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53** 。

### DNS 能解析端口吗？

DNS**不能直接解析端口**。

端口是计算机网络中用于区分不同应用程序或服务的标识。在 TCP/IP 协议中，IP 地址用于定位网络中的设备，而端口号则用于标识该设备上的具体应用程序或服务。常见的端口号有 HTTP 服务默认的 80 端口，HTTPS 服务默认的 443 端口等。在建立网络连接时，需要同时指定目标服务器的 IP 地址和端口号。端口信息并不包含在 DNS 解析的过程中，通常是在应用层的协议（如 HTTP、FTP 等）中规定或者由用户手动指定。例如，在浏览器的地址栏中输入 `http://www.example.com:8080`，这里的 `8080` 就是手动指定的端口号。

### DNS 服务器有哪些？

DNS 服务器自底向上可以依次分为以下几个层级（所有 DNS 服务器都属于以下四个类别之一）：

- 根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。
- 顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如`com`、`org`、`net`和`edu`等。国家也有自己的顶级域，如`uk`、`fr`和`ca`。TLD 服务器提供了权威 DNS 服务器的 IP 地址。
- 权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。

- 本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构

世界上并不是只有 13 台根服务器，这是很多人普遍的误解，网上很多文章也是这么写的。实际上，现在根服务器数量远远超过这个数量。最初确实是为 DNS 根服务器分配了 13 个 IP 地址，每个 IP 地址对应一个不同的根 DNS 服务器。然而，由于互联网的快速发展和增长，这个原始的架构变得不太适应当前的需求。为了提高 DNS 的可靠性、安全性和性能，目前这 13 个 IP 地址中的每一个都有多个服务器，截止到 2023 年底，所有根服务器之和达到了 1700 多台，未来还会继续增加。

### DNS 解析的过程是什么样的？

#### 递归查询

- **本地 DNS 服务器**：用户发起域名请求，本地设备将请求发送给本地 DNS 服务器。若本地 DNS 服务器有该域名的缓存记录，直接返回 IP 地址。
- **根 DNS 服务器**：若本地 DNS 服务器无缓存，它向根 DNS 服务器查询，根 DNS 服务器返回顶级域（如.com、.cn）DNS 服务器地址。
- **顶级域 DNS 服务器**：本地 DNS 服务器再向顶级域 DNS 服务器查询，得到权威 DNS 服务器地址。
- **权威 DNS 服务器**：最后本地 DNS 服务器向权威 DNS 服务器查询，获取域名对应的 IP 地址并返回给用户，同时可将结果缓存。

#### 迭代查询

由本地 DNS 服务器依次向根、顶级域、权威 DNS 服务器查询，每次查询得到下一步要查询的服务器地址，直至获取 IP 地址。

### DNS 劫持了解吗？如何应对？

DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。

#### 用户层面

- **修改 DNS 服务器**：将设备的 DNS 服务器修改为公共且信誉良好的 DNS 服务器，如阿里云的 223.5.5.5、223.6.6.6，谷歌的 8.8.8.8、8.8.4.4。
- **使用 HTTPS 网站**：HTTPS 可加密数据传输，降低劫持后信息泄露风险。尽量访问有 HTTPS 协议的网站。
- **安装安全软件**：安装知名杀毒软件和防火墙，实时监控和拦截恶意程序及 DNS 攻击。

#### 网站运营者层面

- **配置 DNSSEC**：启用 DNSSEC（域名系统安全扩展），验证 DNS 查询响应的真实性和完整性，防止攻击者篡改 DNS 记录。
- **使用 CDN**：借助 CDN（内容分发网络）的抗攻击能力和节点优势，保障域名解析正常。
- **监控与应急处理**：持续监控 DNS 解析情况，发现异常及时联系 DNS 服务提供商处理，同时做好应急响应预案。

### IP 协议的作用是什么？

**IP（Internet Protocol，网际协议）** 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

### 什么是 IP 地址？IP 寻址如何工作？

每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 **IP 地址（Internet Protocol address）**，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。

当网络设备发送 IP 数据包时，数据包中包含了 **源 IP 地址** 和 **目的 IP 地址** 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。

网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。

这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。

![IP 地址使数据包到达其目的地](frequentQ.assets/internet_protocol_ip_address_diagram.png)

### IPv4 和 IPv6 有什么区别？

**IPv4（Internet Protocol version 4）** 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。

为了解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议 - **IPv6（Internet Protocol version 6）**。IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。

除了更大的地址空间之外，IPv6 的优势还包括：

+ **无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）**：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。
+ **NAT（Network Address Translation，网络地址转换） 成为可选项**：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。
+ **对标头结构进行了改进**：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。
+ **可选的扩展头**：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。
+ **ICMPv6（Internet Control Message Protocol for IPv6）**：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。


