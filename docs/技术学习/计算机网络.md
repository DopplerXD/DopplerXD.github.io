## TCP 和 UDP 区别
+ **连接方式**
    - **TCP**：面向连接的协议，在数据传输前需要先建立连接，传输完成后释放连接。
    - **UDP**：无连接的协议，发送数据前不需要建立连接，直接将数据包发送出去。
+ **可靠性**
    - **TCP**：提供可靠的传输服务，通过序列号、确认应答、重传机制等保证数据的准确无误和顺序性。
    - **UDP**：不保证数据的可靠传输，可能会出现丢包、乱序等情况，但传输效率高。
+ **应用场景**
    - **TCP**：适用于对数据准确性和可靠性要求高的场景，如文件传输、电子邮件、网页浏览等。
    - **UDP**：适用于对实时性要求高、能容忍一定数据丢失的场景，如视频直播、音频通话、在线游戏等。

## 从输入网址到看到页面，经历了哪些过程
+ **域名解析**：浏览器将输入的域名通过 DNS 服务器解析为对应的 IP 地址。
+ **建立连接**：浏览器与服务器通过 TCP 协议建立连接，进行三次握手。
+ **发送请求**：浏览器向服务器发送 HTTP 请求，请求包含请求方法、URL、请求头、请求体等信息。
+ **服务器处理请求**：服务器接收到请求后，根据请求的内容进行相应的处理，如查询数据库、执行业务逻辑等。
+ **返回响应**：服务器将处理结果封装成 HTTP 响应，包括响应状态码、响应头、响应体等信息，发送给浏览器。
+ **浏览器渲染页面**：浏览器接收到响应后，根据 HTML、CSS 和 JavaScript 等文件，渲染出页面内容并展示给用户。

## WebSocket 原理是什么
WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，它使得客户端和服务器之间能够进行实时、双向的数据传输。

+ WebSocket 通过在客户端和服务器之间建立一个持久的双向通信连接来实现。在建立连接时，客户端发送一个 HTTP 请求到服务器，请求升级协议为 WebSocket。服务器如果支持 WebSocket 协议，就会响应一个成功的消息，然后双方就可以通过这个连接进行数据的双向传输，而不需要像 HTTP 那样每次请求都要建立连接和断开连接，大大提高了实时性和性能。
+ **握手阶段**：客户端首先向服务器发送一个 HTTP 请求，请求升级协议到 WebSocket。这个请求包含了一些特殊的头信息，如`Upgrade: websocket`和`Connection: Upgrade`，告诉服务器客户端希望建立一个 WebSocket 连接。服务器收到请求后，如果支持 WebSocket 协议，就会返回一个状态码为`101 Switching Protocols`的响应，表示同意升级协议，握手成功。
+ **数据传输阶段**：握手成功后，连接就建立起来了，客户端和服务器可以随时互相发送数据。数据以帧的形式进行传输，每个帧包含了数据的类型、长度以及实际的数据内容。WebSocket 协议定义了多种帧类型，如文本帧、二进制帧等，以支持不同类型的数据传输。在数据传输过程中，连接会一直保持打开状态，直到客户端或服务器主动关闭连接。
+ **优势**：与传统的 HTTP 轮询或长轮询相比，WebSocket 大大减少了网络开销，提高了实时性。因为它不需要像 HTTP 请求那样每次都发送大量的头信息，并且可以在有数据时立即发送，而不需要客户端不断地发送请求来检查是否有新数据。

## 常见状态码
+ **1xx**：信息性状态码，表示服务器已收到请求，正在处理中。
+ **2xx**：成功状态码，表示请求已成功被服务器接收、理解并处理。如 200 OK 表示请求成功。
+ **3xx**：重定向状态码，表示需要客户端采取进一步的操作来完成请求。如 301 Moved Permanently 表示永久重定向，302 Found 表示临时重定向。
+ **4xx**：客户端错误状态码，表示客户端发送的请求有错误。如 400 Bad Request 表示客户端请求有误，401 Unauthorized 表示未授权，404 Not Found 表示请求的资源不存在。
+ **5xx**：服务器错误状态码，表示服务器在处理请求时发生了错误。如 500 Internal Server Error 表示服务器内部错误，503 Service Unavailable 表示服务器暂时不可用。

## 301 302 304 的区别
+ **301**：永久重定向，告诉搜索引擎和浏览器该页面的 URL 已永久改变，应该更新缓存中的链接。
+ **302**：临时重定向，表明页面的 URL 是临时改变的，搜索引擎和浏览器不应该更新缓存中的链接，下次请求时仍应使用原来的 URL。
+ **304**：未修改，当客户端再次请求相同的资源时，服务器返回 304 状态码，表示资源未被修改，客户端可以直接使用本地缓存的资源，从而减少数据传输和提高性能。

## 说说 IO 多路复用
### 概念
IO 多路复用是一种同步 IO 模型，它允许单个线程同时监视多个文件描述符（如套接字）的读写就绪状态，当其中任何一个或多个文件描述符就绪时，线程能够得知并进行相应的读写操作。这样可以避免为每个文件描述符创建一个线程，从而减少系统开销，提高系统的并发处理能力。

### 常见实现
+ **select**：它是最早的 IO 多路复用实现方式，通过一个描述符集合来监视多个文件描述符的状态变化。其缺点是支持的文件描述符数量有限（通常为 1024），并且每次调用 select 时都需要将描述符集合从用户空间复制到内核空间，性能开销较大。
+ **poll**：与 select 类似，但它没有文件描述符数量的限制，采用链表来存储描述符，避免了 select 中数组大小的限制。不过，它仍然存在每次调用时需要复制描述符集合的问题。
+ **epoll**：是 Linux 特有的 IO 多路复用机制，它采用事件驱动的方式，使用红黑树和链表来管理文件描述符。epoll 只需要在注册文件描述符时将其从用户空间复制到内核空间，之后内核会自动通知哪些文件描述符就绪，无需每次都复制描述符集合，大大提高了性能，尤其适用于大量并发连接的场景。

### 应用场景
适用于高并发的网络编程场景，如 Web 服务器、数据库服务器等。在这些场景中，需要处理大量的客户端连接，使用 IO 多路复用可以有效地提高服务器的并发处理能力和资源利用率。

