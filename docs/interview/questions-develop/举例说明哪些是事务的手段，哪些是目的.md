事务通过 **AID**（原子性、隔离性、持久性）保证 **一致性（Consistency）**。

### 1. 原子性（Atomicity）

**作用**：事务内的操作要么全部成功，要么全部失败回滚。  

**如何保证一致性**：

- 若事务中途失败，回滚所有修改，避免数据部分更新导致矛盾。  

```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE user = 'A'; -- A扣款
UPDATE accounts SET balance = balance + 100 WHERE user = 'B'; -- B收款
COMMIT; -- 全部成功或全部回滚
```

如果 B 的收款失败，A 的扣款也会撤销，确保总金额不变（一致性）。

### 2. 隔离性（Isolation）

**作用**：事务并发执行时互不干扰，避免脏读、不可重复读等问题。  

**如何保证一致性**：

- 通过锁或 MVCC 机制隔离其他事务的中间状态，防止读到临时矛盾数据。  

```sql
-- 事务1（转账）
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE user = 'A'; -- 其他事务此时看不到A的未提交修改

-- 事务2（查询）
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE user = 'A'; -- 读不到事务1未提交的修改，避免脏读
COMMIT;
```

隔离性确保事务2不会读到事务1未提交的中间状态，避免数据逻辑矛盾。

### 3. 持久性（Durability）

**作用**：事务提交后，修改永久保存到磁盘。  

**如何保证一致性**：

- 通过 WAL（Write-Ahead Logging）等机制，即使系统崩溃，重启后也能恢复已提交事务。  

```sql
COMMIT; -- 提交后，数据立即写入磁盘日志，即使崩溃也不会丢失
```

持久性确保已提交的事务不会因系统故障回滚，维持数据最终一致。

### AID 如何共同保证一致性？

1. **原子性**：防止部分修改导致数据矛盾。
2. **隔离性**：防止并发事务读到中间状态。
3. **持久性**：确保已提交的修改永久生效。

**最终效果**：数据库始终从一个一致状态转换到另一个一致状态（如转账前后总金额不变）。

### 违反 AID 导致不一致的例子

| **属性** | **违反后果**       | **示例**         |
| ------ | -------------- | -------------- |
| 原子性    | 部分更新（A扣款但B未收款） | 转账中途崩溃，钱丢失     |
| 隔离性    | 脏读、幻读          | 读到未提交的转账导致错误统计 |
| 持久性    | 提交后数据丢失        | 转账成功但崩溃后回滚     |
