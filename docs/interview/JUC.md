## <font style="background-color:rgba(255, 255, 255, 0);">线程和进程的区别</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">定义</font>**<font style="background-color:rgba(255, 255, 255, 0);">：进程是</font>**<font style="background-color:rgba(255, 255, 255, 0);">程序</font>**<font style="background-color:rgba(255, 255, 255, 0);">在操作系统中的</font>**<font style="background-color:rgba(255, 255, 255, 0);">一次执行过程</font>**<font style="background-color:rgba(255, 255, 255, 0);">，是系统进行资源分配和调度的</font>**<font style="background-color:rgba(255, 255, 255, 0);">基本单位</font>**<font style="background-color:rgba(255, 255, 255, 0);">；线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">资源占用</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>**<font style="background-color:rgba(255, 255, 255, 0);">进程</font>**<font style="background-color:rgba(255, 255, 255, 0);">拥有自己</font>**<font style="background-color:rgba(255, 255, 255, 0);">独立</font>**<font style="background-color:rgba(255, 255, 255, 0);">的内存空间和系统资源，而</font>**<font style="background-color:rgba(255, 255, 255, 0);">同一进程内的线程共享</font>**<font style="background-color:rgba(255, 255, 255, 0);">进程的资源，如内存、文件句柄等。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">调度开销</font>**<font style="background-color:rgba(255, 255, 255, 0);">：进程的创建、销毁和切换开销</font>**<font style="background-color:rgba(255, 255, 255, 0);">较大</font>**<font style="background-color:rgba(255, 255, 255, 0);">，线程的创建、销毁和切换开销相对</font>**<font style="background-color:rgba(255, 255, 255, 0);">较小</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">并发能力</font>**<font style="background-color:rgba(255, 255, 255, 0);">：一个进程可以包含多个线程，多个线程可以并发执行，提高了程序的并发处理能力。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">对并发编程的了解，有哪些锁？</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">并发编程</font>**<font style="background-color:rgba(255, 255, 255, 0);">：指在同一时间段内，多个任务可以同时执行的编程方式。Java 中通过多线程实现并发编程，以提高程序的性能和响应速度。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">常见锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>**<font style="background-color:rgba(255, 255, 255, 0);">：Java 内置的同步锁，可修饰方法或代码块，保证同一时刻只有一个线程可以访问被保护的资源。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>**<font style="background-color:rgba(255, 255, 255, 0);">：可重入锁，功能比</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">更强大，支持公平锁和非公平锁，可手动加锁和解锁。</font>
        * **<font style="background-color:rgba(255, 255, 255, 0);">公平锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font><font style="background-color:rgba(255, 255, 255, 0);">指多个线程</font>**<font style="background-color:rgba(255, 255, 255, 0);">按照申请</font>**<font style="background-color:rgba(255, 255, 255, 0);">锁的</font>**<font style="background-color:rgba(255, 255, 255, 0);">顺序</font>**<font style="background-color:rgba(255, 255, 255, 0);">来获取锁，就像排队一样，</font>**<font style="background-color:rgba(255, 255, 255, 0);">先到先得</font>**<font style="background-color:rgba(255, 255, 255, 0);">。当一个线程请求公平锁时，如果锁当前被其他线程持有，那么该线程会被放入等待队列中，当锁被释放时，等待队列中排在最前面的线程会获得锁。缺点是由于需要维护一个等待队列，</font>**<font style="background-color:rgba(255, 255, 255, 0);">线程上下文切换的开销较大，性能相对较低</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
        * **<font style="background-color:rgba(255, 255, 255, 0);">非公平锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>**<font style="background-color:rgba(255, 255, 255, 0);">不保证</font>**<font style="background-color:rgba(255, 255, 255, 0);">线程获取锁的</font>**<font style="background-color:rgba(255, 255, 255, 0);">顺序</font>**<font style="background-color:rgba(255, 255, 255, 0);">，当锁被释放时，任何一个等待锁的线程</font>**<font style="background-color:rgba(255, 255, 255, 0);">都有机会</font>**<font style="background-color:rgba(255, 255, 255, 0);">获得锁，而不是按照申请锁的顺序。非公平锁减少了线程上下文切换的开销，</font>**<font style="background-color:rgba(255, 255, 255, 0);">性能较高</font>**<font style="background-color:rgba(255, 255, 255, 0);">。但可能会导致某些线程长期无法获得锁，出现 </font>**<font style="background-color:rgba(255, 255, 255, 0);">“饥饿” 现象</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">ReadWriteLock</font>**<font style="background-color:rgba(255, 255, 255, 0);">：读写锁，分为读锁和写锁，</font>**<font style="background-color:rgba(255, 255, 255, 0);">允许</font>**<font style="background-color:rgba(255, 255, 255, 0);">多个线程</font>**<font style="background-color:rgba(255, 255, 255, 0);">同时</font>**<font style="background-color:rgba(255, 255, 255, 0);">获取</font>**<font style="background-color:rgba(255, 255, 255, 0);">读</font>**<font style="background-color:rgba(255, 255, 255, 0);">锁，但</font>**<font style="background-color:rgba(255, 255, 255, 0);">写锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">是</font>**<font style="background-color:rgba(255, 255, 255, 0);">排他</font>**<font style="background-color:rgba(255, 255, 255, 0);">的。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">StampedLock</font>**<font style="background-color:rgba(255, 255, 255, 0);">：JDK 8 引入的锁，支持乐观读、悲观读和写锁，性能更好。</font>
        * **<font style="background-color:rgba(255, 255, 255, 0);">适合读多写少</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景：</font><font style="background-color:rgba(255, 255, 255, 0);">提供了乐观读锁，读操作时无需加锁，可直接读取数据，仅在读取后检查数据是否被修改，若未修改则读取有效，避免了传统读写锁读操作加锁带来的性能开销，提升了并发读性能。例如缓存系统，多个线程频繁读取缓存数据，偶尔有线程更新缓存内容。</font>
        * <font style="background-color:rgba(255, 255, 255, 0);">可容忍</font>**<font style="background-color:rgba(255, 255, 255, 0);">短暂数据不一致</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景：乐观读锁允许在读取数据时其他线程进行写操作，因此读取的数据可能是过期的。若业务场景能接受这种短暂的数据不一致性，使用 </font>`<font style="background-color:rgba(255, 255, 255, 0);">StampedLock</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 的乐观读模式可显著提高性能。</font>
        * <font style="background-color:rgba(255, 255, 255, 0);">能够</font>**<font style="background-color:rgba(255, 255, 255, 0);">避免写线程饥饿</font>**<font style="background-color:rgba(255, 255, 255, 0);">：对写操作有较好的支持，能一定程度上避免这种情况，保证写操作能及时执行。例如在一个实时数据更新系统中，写线程负责更新重要数据，需要保证其能及时获取锁进行数据更新。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">Synchronized 和 ReentrantLock 区别</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">锁的获取和释放</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 是 Java 关键字，</font>**<font style="background-color:rgba(255, 255, 255, 0);">自动</font>**<font style="background-color:rgba(255, 255, 255, 0);">获取和释放锁；</font>`<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 需要</font>**<font style="background-color:rgba(255, 255, 255, 0);">手动</font>**<font style="background-color:rgba(255, 255, 255, 0);">调用 </font>`<font style="background-color:rgba(255, 255, 255, 0);">lock()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 和 </font>`<font style="background-color:rgba(255, 255, 255, 0);">unlock()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法来获取和释放锁。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">公平性</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 是</font>**<font style="background-color:rgba(255, 255, 255, 0);">非公平</font>**<font style="background-color:rgba(255, 255, 255, 0);">锁；</font>`<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font>**<font style="background-color:rgba(255, 255, 255, 0);">可</font>**<font style="background-color:rgba(255, 255, 255, 0);">以通过构造函数指定是否为</font>**<font style="background-color:rgba(255, 255, 255, 0);">公平</font>**<font style="background-color:rgba(255, 255, 255, 0);">锁。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">锁的特性</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 提供了</font>**<font style="background-color:rgba(255, 255, 255, 0);">更多的特性</font>**<font style="background-color:rgba(255, 255, 255, 0);">，如可中断锁、超时锁等。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">性能</font>**<font style="background-color:rgba(255, 255, 255, 0);">：在 JDK 6 之前，</font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 性能较差，JDK 6 之后进行了优化，两者</font>**<font style="background-color:rgba(255, 255, 255, 0);">性能差距不大</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">Synchronized 底层原理，锁升级过程和原理</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">底层原理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">基于对象头中的 Mark Word 实现。Mark Word 是对象头的一部分，用于存储对象的哈希码、分代年龄和锁状态等信息。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">锁升级过程</font>**<font style="background-color:rgba(255, 255, 255, 0);">：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">无锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：对象初始状态为无锁状态。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">偏向锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当一个线程第一次访问同步块并获取锁时，会在对象头的 Mark Word 中记录该线程的 ID，以后该线程再次进入该同步块时无需进行任何同步操作，提高了单线程环境下的性能。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">轻量级锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当有其他线程尝试竞争偏向锁时，偏向锁会升级为轻量级锁。轻量级锁使用 CAS 操作来获取锁，避免了线程的阻塞和唤醒，提高了多线程环境下的性能。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">重量级锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当多个线程同时竞争轻量级锁时，轻量级锁会升级为重量级锁。重量级锁会使线程进入阻塞状态，性能较低。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">实现线程安全的方式有哪些</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">Synchronized 关键字</font>**<font style="background-color:rgba(255, 255, 255, 0);">：通过</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">修饰方法或代码块，保证同一时刻只有一个线程可以访问被保护的资源。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>**<font style="background-color:rgba(255, 255, 255, 0);">：使用</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">手动加锁和解锁，实现线程同步。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">原子类</font>**<font style="background-color:rgba(255, 255, 255, 0);">：如</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">AtomicInteger</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">AtomicLong</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">等，使用 CAS 操作保证原子性。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">线程安全的集合</font>**<font style="background-color:rgba(255, 255, 255, 0);">：如</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">ConcurrentHashMap</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">CopyOnWriteArrayList</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">等，内部实现了线程安全机制。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">volatile 关键字</font>**<font style="background-color:rgba(255, 255, 255, 0);">：保证变量的可见性，禁止指令重排序。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">volatile 底层原理</font>
`<font style="background-color:rgba(255, 255, 255, 0);">volatile</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 关键字的底层原理基于内存屏障和 CPU 缓存一致性协议。当一个变量被声明为 </font>`<font style="background-color:rgba(255, 255, 255, 0);">volatile</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 时，会有以下效果：</font>

+ **<font style="background-color:rgba(255, 255, 255, 0);">可见性</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当一个线程修改了</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">volatile</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">变量的值，会立即将该值刷新到主内存中，其他线程在读取该变量时，会直接从主内存中读取，保证了变量的可见性。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">禁止指令重排序</font>**<font style="background-color:rgba(255, 255, 255, 0);">：编译器和处理器在进行指令优化时，会遵守 </font>`<font style="background-color:rgba(255, 255, 255, 0);">volatile</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 变量的读写顺序，不会将 </font>`<font style="background-color:rgba(255, 255, 255, 0);">volatile</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 变量的读写操作重排序到其他指令之前或之后。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">CAS 概念和原理</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">概念</font>**<font style="background-color:rgba(255, 255, 255, 0);">：CAS（Compare-And-Swap）是一种</font>**<font style="background-color:rgba(255, 255, 255, 0);">无锁</font>**<font style="background-color:rgba(255, 255, 255, 0);">算法，用于</font>**<font style="background-color:rgba(255, 255, 255, 0);">实现原子操作</font>**<font style="background-color:rgba(255, 255, 255, 0);">。它包含三个操作数：内存位置（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相等，则将该位置的值更新为新值，否则不做任何操作。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">原理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：CAS 操作是通过 CPU 的原子指令实现的，保证了操作的原子性。在 Java 中，</font>`<font style="background-color:rgba(255, 255, 255, 0);">Atomic</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 系列类就是基于 CAS 实现的。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">聊一下知道的线程池（执行流程、创建参数等）</font>
[<font style="background-color:rgba(255, 255, 255, 0);">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</font>](https://javaguide.cn/java/concurrent/java-thread-pool-summary.html)

<font style="background-color:rgba(255, 255, 255, 0);">线程池是一种多线程处理技术，它维护着一个线程集合，</font>**<font style="background-color:rgba(255, 255, 255, 0);">用于管理和复用线程</font>**<font style="background-color:rgba(255, 255, 255, 0);">，能够减少频繁创建和销毁线程带来的开销，以提高线程的使用效率和系统性能。</font>

+ **<font style="background-color:rgba(255, 255, 255, 0);">工作原理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：线程池创建时会初始化一定数量的线程并放入线程池中。当有任务提交时，线程池会从池中选取一个空闲线程来执行任务。任务执行完毕后，线程不会被销毁，而是返回线程池等待下一个任务，以此实现线程的复用。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">核心组件</font>**<font style="background-color:rgba(255, 255, 255, 0);">：通常包含任务队列、线程集合、线程工厂、拒绝策略等部分。任务队列用于存放待执行的任务；线程集合存储了线程池中的所有线程；线程工厂负责创建新线程；拒绝策略则在任务队列已满且线程池中的线程都在忙碌时，决定如何处理新提交的任务。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">优点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：可以</font>**<font style="background-color:rgba(255, 255, 255, 0);">减少线程创建和销毁的开销</font>**<font style="background-color:rgba(255, 255, 255, 0);">，提高响应速度，因为无需每次执行任务时都创建新线程。同时，它还能</font>**<font style="background-color:rgba(255, 255, 255, 0);">有效控制线程数量</font>**<font style="background-color:rgba(255, 255, 255, 0);">，避免因线程过多导致系统资源耗尽，增强了系统的稳定性和可靠性。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">应用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：广泛应用于各种需要处理大量并发任务的场景，如 Web 服务器处理客户端请求、消息队列的消费者处理消息、分布式系统中的任务调度等。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">执行流程</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    1. <font style="background-color:rgba(255, 255, 255, 0);">当有新任务提交时，线程池会先判断核心线程数是否已满，如果未满，则创建新的核心线程来执行任务。</font>
    2. <font style="background-color:rgba(255, 255, 255, 0);">如果核心线程数已满，会将任务放入任务队列中。</font>
    3. <font style="background-color:rgba(255, 255, 255, 0);">如果任务队列已满，会判断线程池的最大线程数是否已满，如果未满，则创建新的非核心线程来执行任务。</font>
    4. <font style="background-color:rgba(255, 255, 255, 0);">如果最大线程数也已满，会根据拒绝策略处理该任务。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">创建参数</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">corePoolSize</font>**<font style="background-color:rgba(255, 255, 255, 0);">：核心线程数，线程池始终保持的线程数量。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">maximumPoolSize</font>**<font style="background-color:rgba(255, 255, 255, 0);">：最大线程数，线程池允许的最大线程数量。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">keepAliveTime</font>**<font style="background-color:rgba(255, 255, 255, 0);">：线程空闲时间，当线程空闲时间超过该值时，非核心线程会被销毁。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">unit</font>**<font style="background-color:rgba(255, 255, 255, 0);">：时间单位，用于指定</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">keepAliveTime</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">的时间单位。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">workQueue</font>**<font style="background-color:rgba(255, 255, 255, 0);">：任务队列，用于存储等待执行的任务。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">threadFactory</font>**<font style="background-color:rgba(255, 255, 255, 0);">：线程工厂，用于创建线程。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">handler</font>**<font style="background-color:rgba(255, 255, 255, 0);">：拒绝策略，当任务队列和线程池都已满时，如何处理新提交的任务。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">有哪些常用的任务队列和拒绝策略？</font>
### <font style="background-color:rgba(255, 255, 255, 0);">常用任务队列</font>
<font style="background-color:rgba(255, 255, 255, 0);">任务队列用于存放提交但尚未被执行的任务，</font>`<font style="background-color:rgba(255, 255, 255, 0);">ThreadPoolExecutor</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 支持以下几种常用的任务队列：</font>

+ `**<font style="background-color:rgba(255, 255, 255, 0);">ArrayBlockingQueue</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：这是一个</font>**<font style="background-color:rgba(255, 255, 255, 0);">有界</font>**<font style="background-color:rgba(255, 255, 255, 0);">阻塞队列，基于数组实现。创建时需要指定队列的容量，一旦队列</font>**<font style="background-color:rgba(255, 255, 255, 0);">满了</font>**<font style="background-color:rgba(255, 255, 255, 0);">，新任务将</font>**<font style="background-color:rgba(255, 255, 255, 0);">无法加入</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适用于需要</font>**<font style="background-color:rgba(255, 255, 255, 0);">严格控制</font>**<font style="background-color:rgba(255, 255, 255, 0);">并发任务</font>**<font style="background-color:rgba(255, 255, 255, 0);">数量</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，可避免系统资源过度消耗。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">LinkedBlockingQueue</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：这是一个基于链表实现的阻塞队列，有两种情况。若创建时</font>**<font style="background-color:rgba(255, 255, 255, 0);">指定了容量</font>**<font style="background-color:rgba(255, 255, 255, 0);">，它就是</font>**<font style="background-color:rgba(255, 255, 255, 0);">有界</font>**<font style="background-color:rgba(255, 255, 255, 0);">队列；若</font>**<font style="background-color:rgba(255, 255, 255, 0);">不指定</font>**<font style="background-color:rgba(255, 255, 255, 0);">容量，默认容量为 </font>`<font style="background-color:rgba(255, 255, 255, 0);">Integer.MAX_VALUE</font>`<font style="background-color:rgba(255, 255, 255, 0);">，</font>**<font style="background-color:rgba(255, 255, 255, 0);">可视为无界</font>**<font style="background-color:rgba(255, 255, 255, 0);">队列。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：指定容量时，和 </font>`<font style="background-color:rgba(255, 255, 255, 0);">ArrayBlockingQueue</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 类似；不指定容量时，</font>**<font style="background-color:rgba(255, 255, 255, 0);">适合任务处理速度比提交速度慢</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，但要注意可能导致内存溢出。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">SynchronousQueue</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：这是一个</font>**<font style="background-color:rgba(255, 255, 255, 0);">不存储元素</font>**<font style="background-color:rgba(255, 255, 255, 0);">的阻塞队列，每个</font>**<font style="background-color:rgba(255, 255, 255, 0);">插入</font>**<font style="background-color:rgba(255, 255, 255, 0);">操作</font>**<font style="background-color:rgba(255, 255, 255, 0);">必须等待</font>**<font style="background-color:rgba(255, 255, 255, 0);">另一个线程的</font>**<font style="background-color:rgba(255, 255, 255, 0);">移除</font>**<font style="background-color:rgba(255, 255, 255, 0);">操作，反之亦然。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适合任务执行时间短、提交频繁的场景，能减少任务在队列中的等待时间。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">PriorityBlockingQueue</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：这是一个</font>**<font style="background-color:rgba(255, 255, 255, 0);">支持优先级</font>**<font style="background-color:rgba(255, 255, 255, 0);">的</font>**<font style="background-color:rgba(255, 255, 255, 0);">无界</font>**<font style="background-color:rgba(255, 255, 255, 0);">阻塞队列，元素会按照优先级排序。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适用于任务有不同优先级的场景，优先级高的任务会优先被执行。</font>

### <font style="background-color:rgba(255, 255, 255, 0);">常用拒绝策略</font>
<font style="background-color:rgba(255, 255, 255, 0);">当线程池中的线程都在忙碌且任务队列已满时，新提交的任务会触发拒绝策略。</font>`<font style="background-color:rgba(255, 255, 255, 0);">ThreadPoolExecutor</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 提供了以下几种常用的拒绝策略：</font>

+ `**<font style="background-color:rgba(255, 255, 255, 0);">AbortPolicy</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：这是默认的拒绝策略，当触发拒绝时，会</font>**<font style="background-color:rgba(255, 255, 255, 0);">直接抛</font>**<font style="background-color:rgba(255, 255, 255, 0);">出 </font>`<font style="background-color:rgba(255, 255, 255, 0);">RejectedExecutionException</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font>**<font style="background-color:rgba(255, 255, 255, 0);">异常</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适用于希望让调用者</font>**<font style="background-color:rgba(255, 255, 255, 0);">感知到任务无法执行</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，调用者可根据异常进行相应处理。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">CallerRunsPolicy</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当触发拒绝时，会</font>**<font style="background-color:rgba(255, 255, 255, 0);">将任务返回给调用者线程执行</font>**<font style="background-color:rgba(255, 255, 255, 0);">，即哪个线程提交的任务，就由哪个线程来执行该任务。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适合</font>**<font style="background-color:rgba(255, 255, 255, 0);">不希望任务丢失且对性能要求不高</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，可降低新任务的提交速度。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">DiscardPolicy</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当触发拒绝时，会</font>**<font style="background-color:rgba(255, 255, 255, 0);">直接丢</font>**<font style="background-color:rgba(255, 255, 255, 0);">弃新提交的任务，不会抛出任何异常。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适用于</font>**<font style="background-color:rgba(255, 255, 255, 0);">对</font>**<font style="background-color:rgba(255, 255, 255, 0);">任务</font>**<font style="background-color:rgba(255, 255, 255, 0);">丢失不敏感</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，如一些统计类任务。</font>
+ `**<font style="background-color:rgba(255, 255, 255, 0);">DiscardOldestPolicy</font>**`
    - **<font style="background-color:rgba(255, 255, 255, 0);">特点</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当触发拒绝时，会</font>**<font style="background-color:rgba(255, 255, 255, 0);">丢</font>**<font style="background-color:rgba(255, 255, 255, 0);">弃任务队列中</font>**<font style="background-color:rgba(255, 255, 255, 0);">最老</font>**<font style="background-color:rgba(255, 255, 255, 0);">的任务，然后</font>**<font style="background-color:rgba(255, 255, 255, 0);">尝试</font>**<font style="background-color:rgba(255, 255, 255, 0);">将</font>**<font style="background-color:rgba(255, 255, 255, 0);">新</font>**<font style="background-color:rgba(255, 255, 255, 0);">任务</font>**<font style="background-color:rgba(255, 255, 255, 0);">加</font>**<font style="background-color:rgba(255, 255, 255, 0);">入队列。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">适用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：适用于</font>**<font style="background-color:rgba(255, 255, 255, 0);">希望执行最新任务</font>**<font style="background-color:rgba(255, 255, 255, 0);">的场景，可保证新任务有机会被执行。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">为什么 LinkedBlockingQueue 适合任务处理速度比提交速度慢的场景</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">缓冲能力强</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">LinkedBlockingQueue</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 可以是无界队列，默认容量为 </font>`<font style="background-color:rgba(255, 255, 255, 0);">Integer.MAX_VALUE</font>`<font style="background-color:rgba(255, 255, 255, 0);">。这意味着它理论上可以无限容纳新提交的任务，能在任务处理速度较慢时，为大量等待处理的任务</font>**<font style="background-color:rgba(255, 255, 255, 0);">提供缓冲空间，减少任务被拒绝的可能性</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">阻塞机制合理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：当生产者（提交任务的线程）向队列中添加任务时，如果队列已满，生产者线程会被阻塞，直到有消费者（处理任务的线程）从队列中取出任务，腾出空间。这种阻塞机制可以协调生产者和消费者的速度，避免因任务提交过快而导致系统资源耗尽或程序崩溃。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">并发性能较好</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">LinkedBlockingQueue</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 内部采用了</font>**<font style="background-color:rgba(255, 255, 255, 0);">分离的锁机制</font>**<font style="background-color:rgba(255, 255, 255, 0);">，分别用于读写操作，这使得在高并发环境下，</font>**<font style="background-color:rgba(255, 255, 255, 0);">生产者和消费者可以同时访问队列</font>**<font style="background-color:rgba(255, 255, 255, 0);">，提高了队列的并发性能。即使任务提交速度快，处理速度慢，也能在一定程度上保证系统的稳定性和响应性。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">核心线程数为 0 的情况怎么处理？</font>
<font style="background-color:rgba(255, 255, 255, 0);">当核心线程数为 0 时，新提交的任务会直接放入任务队列中。如果任务队列已满，会根据最大线程数和拒绝策略来处理任务。由于没有核心线程，线程池在</font>**<font style="background-color:rgba(255, 255, 255, 0);">没有任务时不会占用系统资源</font>**<font style="background-color:rgba(255, 255, 255, 0);">，但在有新任务提交时，需要创建新的线程来执行任务，</font>**<font style="background-color:rgba(255, 255, 255, 0);">可能会有一定的延迟</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">对 ThreadLocal 的了解，它的应用场景</font>
[<font style="background-color:rgba(255, 255, 255, 0);">https://javaguide.cn/java/concurrent/threadlocal.html</font>](https://javaguide.cn/java/concurrent/threadlocal.html)

+ **<font style="background-color:rgba(255, 255, 255, 0);">了解</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">ThreadLocal</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">是一个线程局部变量，它为每个使用该变量的线程都提供一个独立的副本，每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">应用场景</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">数据库连接管理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：每个线程使用独立的数据库连接，避免线程之间的干扰。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">会话管理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：每个线程保存自己的会话信息，方便在不同方法中使用。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">事务管理</font>**<font style="background-color:rgba(255, 255, 255, 0);">：每个线程维护自己的事务状态。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">多线程计数</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">使用</font>****<font style="background-color:rgba(255, 255, 255, 0);"> </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> </font>****<font style="background-color:rgba(255, 255, 255, 0);">关键字</font>**<font style="background-color:rgba(255, 255, 255, 0);">：通过</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Synchronized</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">修饰方法或代码块，保证同一时刻只有一个线程可以对计数器进行操作。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">使用</font>****<font style="background-color:rgba(255, 255, 255, 0);"> </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>**`<font style="background-color:rgba(255, 255, 255, 0);">：手动加锁和解锁，实现线程同步。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">使用原子类</font>**<font style="background-color:rgba(255, 255, 255, 0);">：如 </font>`<font style="background-color:rgba(255, 255, 255, 0);">AtomicInteger</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">AtomicLong</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 等，使用 CAS 操作保证原子性。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">对 AQS 的了解</font>
[<font style="background-color:rgba(255, 255, 255, 0);">https://javaguide.cn/java/concurrent/aqs.html#aqs-%E4%BB%8B%E7%BB%8D</font>](https://javaguide.cn/java/concurrent/aqs.html#aqs-%E4%BB%8B%E7%BB%8D)

<font style="background-color:rgba(255, 255, 255, 0);">AQS（AbstractQueuedSynchronizer）是 Java 并发包中的一个</font>**<font style="background-color:rgba(255, 255, 255, 0);">抽象类</font>**<font style="background-color:rgba(255, 255, 255, 0);">，是</font>**<font style="background-color:rgba(255, 255, 255, 0);">实现锁和同步器的基础框架</font>**<font style="background-color:rgba(255, 255, 255, 0);">。它使用一个 </font>`<font style="background-color:rgba(255, 255, 255, 0);">int</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 类型的状态变量（</font>`<font style="background-color:rgba(255, 255, 255, 0);">state</font>`<font style="background-color:rgba(255, 255, 255, 0);">）来表示同步状态，通过 CAS 操作来修改状态。AQS 内部维护了一个 FIFO 队列，用于存储等待获取锁的线程。许多锁和同步器，如 </font>`<font style="background-color:rgba(255, 255, 255, 0);">ReentrantLock</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">CountDownLatch</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 等，都是基于 AQS 实现的。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">线程池的创建方式</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">使用</font>****<font style="background-color:rgba(255, 255, 255, 0);"> </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Executors</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> </font>****<font style="background-color:rgba(255, 255, 255, 0);">工厂类</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>`<font style="background-color:rgba(255, 255, 255, 0);">Executors</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">提供了一些静态方法来创建不同类型的线程池，如</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">newFixedThreadPool</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">newCachedThreadPool</font>`<font style="background-color:rgba(255, 255, 255, 0);">、</font>`<font style="background-color:rgba(255, 255, 255, 0);">newSingleThreadExecutor</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">等。</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">使用 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">ThreadPoolExecutor</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> 构造函数</font>**<font style="background-color:rgba(255, 255, 255, 0);">：通过 </font>`<font style="background-color:rgba(255, 255, 255, 0);">ThreadPoolExecutor</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 的构造函数手动指定线程池的参数，创建自定义的线程池。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">Executors 是怎么创建线程的</font>
`<font style="background-color:rgba(255, 255, 255, 0);">Executors</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 是一个工具类，提供了一些静态方法来创建不同类型的线程池。这些方法内部实际上是通过 </font>`<font style="background-color:rgba(255, 255, 255, 0);">ThreadPoolExecutor</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 来创建线程池的，只是根据不同的需求设置了不同的参数。例如，</font>`<font style="background-color:rgba(255, 255, 255, 0);">newFixedThreadPool</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法创建一个固定大小的线程池，核心线程数和最大线程数相等，任务队列使用 </font>`<font style="background-color:rgba(255, 255, 255, 0);">LinkedBlockingQueue</font>`<font style="background-color:rgba(255, 255, 255, 0);">。</font>

## <font style="background-color:rgba(255, 255, 255, 0);">多线程的实现方式，两种实现接口有什么区别？</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">实现方式</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">继承 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> 类</font>**<font style="background-color:rgba(255, 255, 255, 0);">：创建一个类继承 </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 类，重写 </font>`<font style="background-color:rgba(255, 255, 255, 0);">run()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法，调用 </font>`<font style="background-color:rgba(255, 255, 255, 0);">start()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法启动线程。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">实现</font>****<font style="background-color:rgba(255, 255, 255, 0);"> </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Runnable</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> </font>****<font style="background-color:rgba(255, 255, 255, 0);">接口</font>**<font style="background-color:rgba(255, 255, 255, 0);">：创建一个类实现</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Runnable</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">接口，实现</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">run()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">方法，然后将该类的实例作为参数传递给</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">类的构造函数，创建</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">对象并调用</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">start()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">方法启动线程。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">实现</font>****<font style="background-color:rgba(255, 255, 255, 0);"> </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Callable</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> </font>****<font style="background-color:rgba(255, 255, 255, 0);">接口</font>**<font style="background-color:rgba(255, 255, 255, 0);">：创建一个类实现</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Callable</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">接口，实现</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">call()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">方法，该方法有返回值。通过</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">FutureTask</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">包装</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Callable</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">对象，再将</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">FutureTask</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">对象传递给</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">类的构造函数，创建</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">对象并调用</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">start()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">方法启动线程。可以通过</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">FutureTask</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">的</font><font style="background-color:rgba(255, 255, 255, 0);"> </font>`<font style="background-color:rgba(255, 255, 255, 0);">get()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> </font><font style="background-color:rgba(255, 255, 255, 0);">方法获取线程执行的结果。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">通过线程池创建</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
+ **<font style="background-color:rgba(255, 255, 255, 0);">区别</font>**<font style="background-color:rgba(255, 255, 255, 0);">：</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">继承 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> 类</font>**<font style="background-color:rgba(255, 255, 255, 0);">：由于 Java 是</font>**<font style="background-color:rgba(255, 255, 255, 0);">单继承</font>**<font style="background-color:rgba(255, 255, 255, 0);">的，继承了 </font>`<font style="background-color:rgba(255, 255, 255, 0);">Thread</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 类就不能再继承其他类，</font>**<font style="background-color:rgba(255, 255, 255, 0);">灵活性较差</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">实现 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Runnable</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> 接口</font>**<font style="background-color:rgba(255, 255, 255, 0);">：可以</font>**<font style="background-color:rgba(255, 255, 255, 0);">避免单继承</font>**<font style="background-color:rgba(255, 255, 255, 0);">的限制，一个类可以实现多个接口，提高了代码的可扩展性和复用性。</font>
    - **<font style="background-color:rgba(255, 255, 255, 0);">实现 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">Callable</font>**`**<font style="background-color:rgba(255, 255, 255, 0);"> 接口</font>**<font style="background-color:rgba(255, 255, 255, 0);">：与 </font>`<font style="background-color:rgba(255, 255, 255, 0);">Runnable</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 接口相比，</font>`<font style="background-color:rgba(255, 255, 255, 0);">Callable</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 接口的 </font>`<font style="background-color:rgba(255, 255, 255, 0);">call()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法</font>**<font style="background-color:rgba(255, 255, 255, 0);">有返回值</font>**<font style="background-color:rgba(255, 255, 255, 0);">，并且</font>**<font style="background-color:rgba(255, 255, 255, 0);">可以抛出异常</font>**<font style="background-color:rgba(255, 255, 255, 0);">。</font>

```java
// 实现 Runnable 接口的任务类
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running.");
    }
}

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建固定大小为 2 的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        // 创建任务
        MyRunnable task1 = new MyRunnable();
        MyRunnable task2 = new MyRunnable();

        // 提交任务到线程池
        executorService.execute(task1);
        executorService.execute(task2);

        // 关闭线程池
        executorService.shutdown();
    }
}
```

```java
// 实现 Callable 接口，泛型指定返回值类型为 Integer
class MyCallable implements Callable<Integer> {
    private final int taskId;

    public MyCallable(int taskId) {
        this.taskId = taskId;
    }

    // 重写 call 方法，该方法会在线程执行时被调用
    @Override
    public Integer call() throws Exception {
        System.out.println("Task " + taskId + " is running.");
        // 模拟任务执行耗时
        Thread.sleep(2000);
        return taskId * 10;
    }
}

public class CallableThreadExample {
    public static void main(String[] args) {
        // 创建一个固定大小为 2 的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        // 用于存储 Future 对象，Future 可用于获取异步任务的结果
        Future<Integer> future1 = executorService.submit(new MyCallable(1));
        Future<Integer> future2 = executorService.submit(new MyCallable(2));

        try {
            // 获取第一个任务的结果
            Integer result1 = future1.get();
            System.out.println("Task 1 result: " + result1);
            // 获取第二个任务的结果
            Integer result2 = future2.get();
            System.out.println("Task 2 result: " + result2);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        // 关闭线程池
        executorService.shutdown();
    }
}    
```

## <font style="background-color:rgba(255, 255, 255, 0);">Java 的线程怎么防止虚假唤醒</font>
<font style="background-color:rgba(255, 255, 255, 0);">在 Java 中，线程的虚假唤醒是指线程在</font>**<font style="background-color:rgba(255, 255, 255, 0);">没有收到明确的通知</font>**<font style="background-color:rgba(255, 255, 255, 0);">时就从等待状态中</font>**<font style="background-color:rgba(255, 255, 255, 0);">被唤醒</font>**<font style="background-color:rgba(255, 255, 255, 0);">。为了防止虚假唤醒，</font>**<font style="background-color:rgba(255, 255, 255, 0);">应该在 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">while</font>**`<font style="background-color:rgba(255, 255, 255, 0);"> 循环中调用 </font>`<font style="background-color:rgba(255, 255, 255, 0);">wait()</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 方法，</font>**<font style="background-color:rgba(255, 255, 255, 0);">而不是在 </font>**`**<font style="background-color:rgba(255, 255, 255, 0);">if</font>**`<font style="background-color:rgba(255, 255, 255, 0);"> 语句中。示例代码如下：</font>

```java
synchronized (lock) {
    while (condition) {
        lock.wait();
    }
    // 执行相应的操作
}
```

<font style="background-color:rgba(255, 255, 255, 0);">在上述代码中，</font>`<font style="background-color:rgba(255, 255, 255, 0);">condition</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 是一个布尔表达式，表示线程等待的条件。当线程被唤醒时，会再次检查 </font>`<font style="background-color:rgba(255, 255, 255, 0);">condition</font>`<font style="background-color:rgba(255, 255, 255, 0);"> 的值，如果条件仍然不满足，线程会继续等待，从而避免了虚假唤醒的问题。</font>

